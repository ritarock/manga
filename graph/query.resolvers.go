package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.24

import (
	"context"
	"errors"
	"strconv"

	"entgo.io/ent/dialect/sql"
	"github.com/ritarock/manga/ent"
	"github.com/ritarock/manga/ent/book"
	"github.com/ritarock/manga/graph/model"
)

// BooksByTitle is the resolver for the booksByTitle field.
func (r *queryResolver) BooksByTitle(ctx context.Context, input string) ([]*model.Book, error) {
	books := []*model.Book{}
	searched := r.EntClient.Book.Query().
		Where(func(s *sql.Selector) {
			s.Where(sql.Like(book.FieldTitle, "%"+input+"%"))
		}).AllX(ctx)
	for _, book := range searched {
		books = append(books, &model.Book{
			ID:          strconv.Itoa(book.ID),
			Isbn:        book.Isbn,
			Title:       book.Title,
			Publisher:   book.Publisher,
			Pubdate:     book.Pubdate,
			Cover:       book.Cover,
			Author:      book.Author,
			SubjectCode: book.SubjectCode,
		})
	}
	return books, nil
}

// BooksByAuthor is the resolver for the booksByAuthor field.
func (r *queryResolver) BooksByAuthor(ctx context.Context, input string) ([]*model.Book, error) {
	books := []*model.Book{}
	searched := r.EntClient.Book.Query().
		Where(func(s *sql.Selector) {
			s.Where(sql.Like(book.FieldAuthor, "%"+input+"%"))
		}).AllX(ctx)
	for _, book := range searched {
		books = append(books, &model.Book{
			ID:          strconv.Itoa(book.ID),
			Isbn:        book.Isbn,
			Title:       book.Title,
			Publisher:   book.Publisher,
			Pubdate:     book.Pubdate,
			Cover:       book.Cover,
			Author:      book.Author,
			SubjectCode: book.SubjectCode,
		})
	}
	return books, nil
}

// Books is the resolver for the books field.
func (r *queryResolver) Books(ctx context.Context, input model.PaginationInput) (*model.BookConnection, error) {
	if input.First == nil && input.Last == nil {
		return nil, errors.New("input.First or input.Last is required")
	}
	if input.First != nil && input.Last != nil {
		return nil, errors.New("input.First and input.Last is not supported")
	}
	if input.Before != nil && input.After != nil {
		return nil, errors.New("input.Before and input.After is not supported")
	}

	var limit int
	if input.First != nil {
		limit = *input.First
	} else {
		limit = *input.Last
	}

	booksSizeLimit := 100
	if input.First != nil && *input.First > booksSizeLimit {
		return nil, errors.New("input.First exceeds booksSizeLimit")
	}
	if input.Last != nil && *input.Last > booksSizeLimit {
		return nil, errors.New("input.Last exceeds booksSizeLimit")
	}

	var books []*model.Book
	var searched []*ent.Book

	if input.After != nil {
		searched = r.EntClient.Book.Query().
			Where(func(s *sql.Selector) {
				s.Where(sql.GT(book.FieldID, input.After))
			}).
			Limit(limit + 1).
			AllX(ctx)
	}
	if input.Before != nil {
		searched = r.EntClient.Book.Query().
			Where(func(s *sql.Selector) {
				s.Where(sql.LT(book.FieldID, input.After))
			}).Order(ent.Desc(book.FieldID)).
			Limit(limit + 1).
			AllX(ctx)
	}
	if input.Last != nil {
		searched = r.EntClient.Book.Query().
			Order(ent.Desc(book.FieldID)).
			Limit(limit + 1).
			AllX(ctx)
	}
	for _, book := range searched {
		books = append(books, &model.Book{
			ID:          strconv.Itoa(book.ID),
			Isbn:        book.Isbn,
			Title:       book.Title,
			Publisher:   book.Publisher,
			Pubdate:     book.Pubdate,
			Cover:       book.Cover,
			Author:      book.Author,
			SubjectCode: book.SubjectCode,
		})
	}

	if len(books) == 0 {
		return &model.BookConnection{
			PageInfo: &model.PageInfo{
				StartCursor:     nil,
				EndCursor:       nil,
				HasNextPage:     false,
				HasPreviousPage: false,
			},
			Edges: []*model.BookEdge{},
			Nodes: []*model.Book{},
		}, nil
	}

	edges := make([]*model.BookEdge, len(books))
	nodes := make([]*model.Book, len(books))

	if input.First != nil || input.After != nil {
		for i, book := range books {
			newEdge := &model.BookEdge{
				Cursor: book.ID,
				Node:   book,
			}
			nodes = books
			edges[i] = newEdge
		}
	} else {
		for i, book := range books {
			newEdge := &model.BookEdge{
				Cursor: book.ID,
				Node:   book,
			}
			nodes[len(books)-1-i] = books[i]
			edges[len(edges)-1-i] = newEdge
		}
	}

	startCursor := edges[0].Cursor
	endCursor := edges[len(edges)-1].Cursor

	var hasPreviousPage bool
	var hasNextPage bool

	startCursorInt, _ := strconv.Atoi(startCursor)
	endCursorInt, _ := strconv.Atoi(endCursor)
	// var book model.Book
	if input.First != nil {
		_, err := r.EntClient.Book.Query().
			Where(func(s *sql.Selector) {
				s.Where(sql.LTE(book.FieldID, startCursorInt-1))
			}).FirstID(ctx)
		if err != nil {
			hasPreviousPage = true
		}
	} else {
		_, err := r.EntClient.Book.Query().
			Where(func(s *sql.Selector) {
				s.Where(sql.GTE(book.FieldID, endCursorInt+1))
			}).FirstID(ctx)
		if err != nil {
			hasNextPage = true
		}
	}

	if input.First != nil && limit < len(nodes) {
		endCursor = edges[len(edges)-2].Cursor
		hasNextPage = true
		return &model.BookConnection{
			PageInfo: &model.PageInfo{
				StartCursor:     &startCursor,
				EndCursor:       &endCursor,
				HasNextPage:     hasNextPage,
				HasPreviousPage: hasPreviousPage,
			},
			Edges: edges[:len(edges)-1],
			Nodes: nodes[:len(nodes)-1],
		}, nil
	} else if input.First != nil && limit >= len(nodes) {
		return &model.BookConnection{
			PageInfo: &model.PageInfo{
				StartCursor:     &startCursor,
				EndCursor:       &endCursor,
				HasNextPage:     hasNextPage,
				HasPreviousPage: hasPreviousPage,
			},
			Edges: edges,
			Nodes: nodes,
		}, nil
	}

	if input.Last != nil && limit < len(nodes) {
		startCursor = edges[len(edges)-limit].Cursor
		hasPreviousPage = true
		return &model.BookConnection{
			PageInfo: &model.PageInfo{
				StartCursor:     &startCursor,
				EndCursor:       &endCursor,
				HasNextPage:     hasNextPage,
				HasPreviousPage: hasPreviousPage,
			},
			Edges: edges[len(edges)-limit:],
			Nodes: nodes[len(nodes)-limit:],
		}, nil
	} else if input.Last != nil && limit >= len(nodes) {
		return &model.BookConnection{
			PageInfo: &model.PageInfo{
				StartCursor:     &startCursor,
				EndCursor:       &endCursor,
				HasNextPage:     hasNextPage,
				HasPreviousPage: hasPreviousPage,
			},
			Edges: edges,
			Nodes: nodes,
		}, nil
	}

	return nil, nil
}

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type queryResolver struct{ *Resolver }
